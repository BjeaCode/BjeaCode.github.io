[{"id":"395958d74d86de310045a30e9bb94d14","title":"2022.01.30","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","slug":"Hello_World","date":"2022-01-29T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"CodeBomb"},{"id":"2cfd37e9f164f459678630859c9747b0","title":"CF587C Duff in the Army","content":"。\n牵制芝士：主席树，。\n题目大意：\n给定一棵个节点的树。有个人，第个人住在节点上。次询问，每次询问如，询问路径上居住的（包括）编号前小的人的编号。如若人数不足，则输出所有人的编号。在输出编号之前，你还应输出你会输出多少编号。\n\n根据题面瞎编的故事版（供欣赏，可以不看）\n正题开始\n回到做法，看到“树”，“路径”，这时候应该已经开始敲了，树剖和倍增均可。\n由于求前小值，还是静态的，对每一个节点开一个桶，记录到树根的信息。然后需要的时候再进行调用即可。\n但是观察数据范围，发现不是很行。\n这里我们可以使用树上主席树的方法，直接记录即可。\n对于每一次询问，我们先求出，然后直接利用主席树求解。\n但是这里有可能是两条链？怎么快速求前小值？\n不慌，我们用分别表示两条链已经取到了第几小值，每一次跑主席树求出后比较即可。\n需要注意的是，注意记录两条链的和，不然到后面因为主席树的一些性质可能导致求根本不存在的值的时候返回两个，这个时候就会炸。判一下。\n","slug":"cf587c","date":"2022-01-26T08:41:00.000Z","categories_index":"题解","tags_index":"主席树,LCA","author_index":"Mr_Stranger_CW"},{"id":"5dd50a8d7b5289fc4ba001ab8881e431","title":"CF516D Drazil and Morning Exercise","content":"。\n题目大意：给定一颗有边权树，记函数表示在整棵树中距离点最远的点与的距离。\n\n现在给定一个上界，求最大联通块个数使得。\n一开始拿到这个题一点头绪都没有，还把题意理解错了，一直以为这个是在选择的联通块中计算的。\n后来我们发现了一些奇妙的性质。性质是啥一会再说，那个是证明会用的。\n将所有j计算出来后，我们将他们排序，然后直接尺取加并查集计算最大点数即可，复杂度。\n为什么是对的？我们在去除点的时候不会破坏并查集所维护的联通性么？\n观察这个，我们可以得出取到最大值的点是在整颗树的直径的两端。\n紧接着发现，对于每一个点，我们一定能找到一个方法让他走到直径上（本来就在就相当于没动）然后向较长的一端走去。\n我们很轻易就能发现直径的终点的取值是最小的。我们钦定直径中点是整颗树的根。\n因为每个在直径上的点一定会向离自己远的直径一段走去，所以一定会经过终点。\n所以当成为根的时候，每一个儿子的取值一定要比父亲的要大。\n故这棵以为根的树是一个小根堆。\n所以当我们将所有的从大到小排序后，在尺子左右端点移动过程中，我们弹出的一个节点他的儿子一定比他先弹出去，所以不对联通性造成破坏。\n并查集维护其即可。\n","slug":"cf516d","date":"2022-01-26T08:35:00.000Z","categories_index":"题解","tags_index":"并查集,树上问题","author_index":"Mr_Stranger_CW"},{"id":"6bfdc763cf1a8e5ceadcb92978492e05","title":"CF372C Watching Fireworks is Fun","content":"\n给定一条有个观测节点的路，你可以选择在原地不动，从移动到()或从移动到()。你每秒进行次这些操作。\n现在有场烟花表演，第场烟花表演的位置在，快乐值为，时间在。\n当第场表演开始时，假设你在观测节点，此时你获得的快乐值是。\n时刻你可以在任意一个节点上，请问当场演出结束之后，你能获得的最大总欢乐值是多少？\n\n先对表演按照时间排序。\n单调队列优化好题。\n我们定义表示的是第场烟火表演开始时在观测节点的最大欢乐值。\n先抓一只朴素的狮子：\n\n时间复杂度为，不是很能接受。\n发现这里面有关的只有，所以当我们只是从路一侧向另一侧推的时候可以用单调队列维护最大值。\n所以左到右转移一遍，再从右到左转移一遍单调队列优化即可。\n当发现当前点和队头距离太大时弹出即可。\n时间复杂度可以通过本题。\n","slug":"cf372c","date":"2022-01-26T08:01:55.000Z","categories_index":"题解","tags_index":"DP,单调队列","author_index":"Mr_Stranger_CW"},{"id":"527eaa72cbc98892b3d0e524de491956","title":"P5468 & P6302 回家路线","content":"回家路线 加强版 正常数据版\n先怼一句啊，原题拿脚造的数据，导致一些离谱的错误能过。\n所以称这版为正常数据版\n回到正题，斜率优化好题。\n给定了一张个点的图，有条单向边,边从到，可以在时刻可以进入，然后在时刻出来。\n现在有一匹牛马出现了，他想从点校门口走到点机房做题，他出现在点  时是时刻。\n牛马不喜欢等待和走过多的路，所以每次离开一个点，都会为他增加的愤怒值，其中是他抵达在这个点等待的时长。而且牛马不喜欢太晚到机房，所以如果他在时刻才进入机房，他会增加的愤怒值。\n牛马很傻很暴躁，当他的愤怒值过高他就会砸桌子。机房大佬需要保证机房桌子的安全，所以需要为牛马规划一条会使他愤怒值尽量小的路线。\n大佬有着惊人的悟性，他只需要知道这个愤怒值就能逆推出路线。所以需要你给出这个愤怒值。\n其中，同时由于学校设计的很好，一定会存在可以让牛马从校门口进入机房的方案。\n小葵花…… 开始解题\n遇事不决我们先对边进行时间排序，防止出现时间倒流。\n然后我们通过观察发现 显然 可以！\n我们定义是在通过边后最小的愤怒值。\n方程？我们知道一条边的起始节点，那么我们一定是要从终点是这个起始节点得边推过来，我们令集合表示到达时间小于等于，终点是的边的集合，那么我们就有：\n\n我们设 \n则 \n拆一下。\n\n 发现可以拆成只与有关，只与有关，和只有前两者的乘积若干部分和常数。\n发现可以斜率优化。\n令 \n于是可以转移。\n现在考虑如何维护的条件。\n我们把每条边按照起始时间排序。\n转移完的边以作为关键字，扔进小根堆中（当然也可以桶排，但是我懒）。每一次转移一条边之前把堆中所有的插入各自终点的平面直角坐标系维护凸包即可。转移的时候直接从起点的坐标系找。\n代码不贴了，除了犯一些错误有手就行。\n由于时间不回溯，所以没有后效性\n","slug":"p5468&p6302_sol","date":"2022-01-25T13:59:04.000Z","categories_index":"题解","tags_index":"DP,斜率优化","author_index":"Mr_Stranger_CW"},{"id":"d6677ef83cf516f9da01e2e0359e5740","title":"基础动态规划优化","content":"蒟蒻浅谈如何尝试入门部分基础优化初步\n斜率优化！\n先给个大概念：对于一只狮子，如果这只狮子可以被表达为以下形式，且狮子中的随着时间的推移（或者说的增大）单调不减，则他可以进行斜率优化。这里以最小值为例子。\n设是仅与变量相关的第个狮子的组成部分。 设是至多只与变量相关的第个狮子的组成部分。  好现在我们来介绍斜率优化的斜率他在哪里。\n对于一条直线我们给他变换一个形式\n得到狮子\n这时候我们发现将最上面的狮子换一个形式，变成。\n我们令：\n\n而我们的目的，是令最小。\n根据一些初中知识，我们发现正是直线的纵截距。\n而原式可以变为\n而在不变的时候，不变。\n所以现在我们的问题转化为，一条斜率为的直线，经过某个点的最小纵截距是多少。\n感性理解一下，现在平面上有很多的点，我们把这条直线从很靠下的地方一点点上移，直到碰到某个点。这个时候纵截距是最小的。\n因为一些显而易见的事实，我们发现这个最先被碰到的点一定在下凸包上。\n所以说，我们对于每一个位置的决策，将作为坐标扔到平面直角坐标系上去单调栈线性维护凸包即可（这也是为什么前面要求单调，不然时间会退化）。\n至于在凸包上我们会碰到那个点就可用二分解决，因为下凸包斜率单调增，所以我们只需要二分出第一个点使得这个点和前面的点的构成斜线的斜率和他和后面的点组成的直线的斜率满足即可，等号取哪边视题目而定。\n这样的话可以把一些需要的动态规划所需的时间压缩到。\n同时，如果说我们发现单调递增，那么我们就可以把下凸包的栈换成双端队列，进行单调队列优化使得时间降为。\n注意边界，如当相等时的斜率计算等。\n最大值记录的话就是把上边那一堆自行反过来。\n四边形不等式优化！\n一般用于区间\n一只狮子形似：  其中的满足：   则我们称之为满足四边形不等式。\n若满足：   则我们称之为满足区间包含单调性。\n满足四边形不等式的动态规划拥有决策单调性，即如果存在一个新决策点比当前最优决策点更优，那么当前的最优决策点在新决策点加入后不可能再次成为最优决策点。\n","slug":"dp_opt","date":"2022-01-24T14:00:44.000Z","categories_index":"学习笔记","tags_index":"DP","author_index":"Mr_Stranger_CW"},{"id":"3fc14b72d62a93ae2f85a78fb690a4a0","title":"蒟蒻的插头DP基础入门初步","content":"一个基于状压哈希的动态规划算法\n本蒟蒻学了半天菜菜把模板题整明白\n其实分类讨论整熟练之后插头还是好理解的\n只要您不像我这蒟蒻一样建完哈希表不插入东西\n进入正文：\n插头，其核心在于插头 废话。\n插头大概长成这个样子：\n\n（有点丑）\n就是在网格图上，每一个格子都有四个插头上下左右。\n现在我们先讨论模板题，在下面这道模板题中我们只需要用到下插头和右插头。\nP5056 【模板】插头DP\n题意简述：给定一张的网格图，保证，其上有若干障碍物，问把所有空地铺上线且使得这些线称为闭合回路的方案数。\n稍微思考一下，你会发现一个神奇的事情，对于一个方格，他上面铺的线的形态应该是由和决定的。这个时候我们来分类讨论一下。（插头的事先别急后面会讲）\n我们先引入轮廓线这个概念，轮廓线指的是已决策和未决策状态的分界线。\n如果说和长成这个样子：\n\n那因为我们要保证闭合回路，所以我们只能这么做：\n\n第二种和解决办法：\n\n第三种和两种解决办法：\n\n\n\n多画几组你会发现，和本身长成啥样不是特别重要，我们需要知道的只是下图中两个位置存不存在线头。\n\n这里我们就可以引入一个概念了，如果说一个位置存在一条线必须按照这个方向从此延伸，则称这个位置存在一个方向的插头。\n问题接踵而至，知道了他有啥用，闭合回路怎么处理？\n别急，我们观察一下，因为保证闭合回路，我们一定会保证在轮廓线上方不存在断点，所有的断点只可能在线上产生，也就是插头。\n所以我们会发现，断点一定成对出现。每一对可以描述一条线轮廓线上方的线，这一大堆线覆盖了轮廓线上方的所有空地。\n而每一个断点都有两种类型：靠左或者靠右废话\n我们以此也把插头分为两类：一类左断点插头，我们称之为类，也叫起点插头；一类右端点插头， 我们称之为类，也叫终点插头。\n所以对于每一个轮廓线上点，有三种情况：没有插头，插头，插头。\n这个味道。。。是状压。\n故因为插头基于状压，所以一般来说数据不大。\n可以三进制压，但是蒟蒻比较懒，一般直接四进制压了，使用位运算还会快一点。\n对于一个的网格图，我们每一次压进去个插头，决策后的状态表示的是第的下插头的右插头的下插头。\n我们记为当前的状态，两个二进制位表示一个插头，。\n我们的状态是一行一行来的，所以我们在计算这个方格时可以用$(nzt&gt;&gt;(2(j-1))) % 4 提取a_{i,j-1}的右插头，用(nzt&gt;&gt;(2j))%4提取a_{i,j-1}的左插头，即P1,P2$。\n所以对于格子，我们可以\n分类讨论开始了：\n特殊情况先考虑一下：这个格子有障碍物，那么显然他的上方和左方不应该存在插头，此时原本状态的第两个插头均为零，转移之后这格没有线，所以第（下标此时变化了一些）两个插头也变成了零，略加思考，原封转移即可。否则无法转移，直接略过，\n以下情况均是该格子不存在障碍物。\n情况，这个时候因为不存在左和上的两个插头，所以我们只能将这个格子的右方和下放连接。这个时候的转移因为我们加入了两个插头，一个在位置的插头，一个在位置的插头，这个时候把原状态改一下，这个新的状态应为。（状态咋改的这里一定要理解，因为下边就全是“大体同上，不会看代码了”，因为确实改个状态真的不难）\n情况，这种情况我们有两种办法，第一种是从上到下，在位置建立一个插头，第二种是从上到左，在位置建立一个插头。状态更改实现大体同上自行思考。\n情况同上，只不过是方向不一样而已。\n情况，这种情况就是两个起点碰到一起了，这样的话我们就需要将两条线中终点靠左的那条线的终点变为起点，因为我们知道，对于轮廓线上四个位置，不可能有是一条线的同时是一条线，这样会矛盾，所以这个靠左的终点一定是所对应的终点，直接从开始向右扫就行。找到之后直接更改。方法和括号匹配一样，为啥的话。。。。都看到这了读者应该是知道的吧。。。。。两两配对不可交叉有左有右。。。。\n情况，同上，只不过是要找起点，从开始向左扫即可。\n情况，一个终点碰到了一个起点，直接连接变成一个，原来两个插头全部变成就可以。\n情况，相当于是要闭合回路了，这个时候能够闭合的要求就是只剩这俩插头了且被闭合的位置是终点，这就不用转移了，直接塞进答案里即可。记表示从上到下从左到右遍历过程中遇到的最后一个没有障碍点的位置，情况能够计算进答案当且仅当。\n注意新建插头的时候判断一下涉及到的方格有没有障碍物。\n分类讨论搞完了，来说实现，记表示在格子决策之后轮廓线上插头状态为的方案数。\n这样的话空间就是，上模板题的范围是的，空间只有，我们要是这么干的话空间大概是不到，所以 可以通过本题 必须要优化\n我们发现很多状态不可能合法，而且直接压缩不能完美利用空间，我们可以使用哈希表来记录状态。\n然后我们发现求我们在计算一个格子的时候只使用了上一个被计算的格子的状态，所以可以滚动数组优化一下。\n哈希的话，我们发现他的总状态是次方左右，在要求括号匹配，暴搜一下，大概总方案数不超过，所以大胆的哈希吧，下面代码用的是链表法哈希表。\n现在的空间只有了，显然是够的，时间复杂度的话就是大概就是在空间的基础上乘上个左右。\n可以通过本题。\n代码：\n//#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;math.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;istream&gt;\n#include &lt;string&gt;\n#include &lt;queue&gt;\n#include &lt;deque&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;string.h&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#define inlind inline void\n#define inlinl inline bool\n#define inlint inline int\n#define inlinc inline char\n#define inlins inline string\n#define mem0(a) memset(a,0,sizeof(a))\n#define memf(a) memset(a,0x3f,sizeof(a))\n#define mem_f(a) memset(a,0x80,sizeof(a))\n#define mem_1(a) memset(a,-1,sizeof(a))\n#define pb(a,b) a.push_back(b)\n#define mp(a,b) make_pair(a,b)\n#define p1(x) x.first\n#define p2(x) x.second\n#define lc(x) sgt[x].ls\n#define rc(x) sgt[x].rs\n#define int long long\nusing namespace std;\ninlind re(int &amp;x) {\n    x=0;\n    bool f=0;\n    int w=getchar();\n    while(w&lt;'0'||w&gt;'9'){if(w=='-')f = 1;w=getchar();}\n    while(w&lt;='9'&amp;&amp;w&gt;='0')x=(x&lt;&lt;3)+(x&lt;&lt;1)+w-'0',w=getchar();\n    if(f)x=-x;\n}\ninlind re(int &amp;x1,int &amp;x2) {\n    re(x1);\n    re(x2);\n}\ninlind wr(int x) {\n    if(x&lt;0)putchar('-'),x=-x;\n    if(x&gt;9)wr(x/10);\n    putchar(x%10+'0');\n}\nint tot[2];\nint ha[2][300000],flag,edx,edy,dp[2][300000];\nint sjz;\nint jz4[15];\nstruct has{\n    int hd[300000],nt[300000];\n    const int M=299993;\n    inlind ins(int zt,int s){\n        int ztm=zt%M+1;\n        for(int i=hd[ztm];i;i=nt[i])\n            if(ha[flag][i]==zt){\n                dp[flag][i]+=s;\n                return ;\n            }\n        nt[++tot[flag]]=hd[ztm];\n        hd[ztm]=tot[flag];\n        ha[flag][tot[flag]]=zt;\n        dp[flag][tot[flag]]=s;\n    }\n    inlind cr(){\n        mem0(hd);\n        tot[flag]=0;\n    }\n}H;\nint n,m;\nbool op[15][15];\nsigned main(){\n    re(n,m);\n    for(int i=1;i&lt;=n;i++)\n        for(char j=1,x;j&lt;=m;j++){\n            cin&gt;&gt;x;\n            if(x=='.')op[i][(int)(j)]=1,edx=i, edy=j;\n        }\n    for(int i=1;i&lt;=max(n,m)+1;i++)jz4[i]=1&lt;&lt;(2*(i-1));\n    flag=0;\n    ha[flag][1]=(tot[0]=dp[0][1]=1)-1;\n    int ans=0;\n    for(int i=1;i&lt;=n;i++){\n        for(int j=1;j&lt;=tot[flag];j++)ha[flag][j]&lt;&lt;=2;\n        for(int j=1;j&lt;=m;j++){\n            flag^=1;\n            H.cr();\n         for(int k=1;k&lt;=tot[flag^1];k++){\n                int nzt=ha[flag^1][k],p1=(nzt&gt;&gt;(2*j-2))%4,p2=(nzt&gt;&gt;(2*j))%4;\n                int diputs03_AKIOI=dp[flag^1][k];\n                if(!op[i][j]){if(!p1&amp;&amp;!p2)H.ins(nzt,diputs03_AKIOI);}\n                else if(!p1&amp;&amp;p2){if(op[i][j+1])H.ins(nzt,diputs03_AKIOI);\n                    if(op[i+1][j])H.ins(nzt+jz4[j]*p2-jz4[j+1]*p2,diputs03_AKIOI); }\n                else if(p1&amp;&amp;!p2){if(op[i+1][j])H.ins(nzt,diputs03_AKIOI);\n                    if(op[i][j+1])H.ins(nzt+jz4[j+1]*p1-jz4[j]*p1,diputs03_AKIOI);}\n                else if(!p1&amp;&amp;!p2){if(op[i+1][j]&amp;&amp;op[i][j+1])\n                        H.ins(nzt+jz4[j]+2*jz4[j+1],diputs03_AKIOI);}\n                else if(p1==1&amp;&amp;p2==2){if(i==edx&amp;&amp;j==edy&amp;&amp;!nzt-(p1&lt;&lt;(2*j-2))-(p2&lt;&lt;(2*j))){\n                        ans+=diputs03_AKIOI;}}\n                else if(p1==2&amp;&amp;p2==1){\n                    H.ins(nzt-2*jz4[j]-jz4[j+1],diputs03_AKIOI);\n\n                }\n                else if(p1==1&amp;&amp;p2==1){\n                    int ct=0;\n                    for(int p=j;p&lt;=m;p++){\n                        if((nzt&gt;&gt;(2*p))%4==1)ct++;\n                        else if((nzt&gt;&gt;(2*p))%4==2)ct--;\n                        if(!ct){ H.ins(nzt-jz4[j]-jz4[j+1]-jz4[p+1],diputs03_AKIOI);break;}\n                    }}\n                else if(p1==2&amp;&amp;p2==2){\n                    int ct=0;\n                    for(int p=j-1;p&gt;=1;p--){\n                        if((nzt&gt;&gt;(2*p))%4==1)ct++;\n                        else if((nzt&gt;&gt;(2*p))%4==2)ct--;\n                        if(!ct){H.ins(nzt-2*jz4[j]-2*jz4[j+1]+jz4[p+1],diputs03_AKIOI);\n                                break;}}}\n            }\n        }\n    }\n    cout&lt;&lt;ans;\n        return 0;\n}\n\n","slug":"dp_plug","date":"2022-01-03T04:02:16.000Z","categories_index":"学习笔记","tags_index":"DP","author_index":"Mr_Stranger_CW"},{"id":"341dfdd9c8daf0da4e97105cf57b53c9","title":"P1251 & P4480 餐巾计划问题","content":"经典的网络 瘤 流题目\n题意：一家餐厅，开天，一开始没有餐巾。第天要用块干净的餐巾，然后他们会变成脏的。购买一块新的餐巾消耗元，脏了的餐巾可以选择送去快洗，送去慢洗，或者存起来回头再洗，快洗用天，花元，慢洗用天，花元，保证且。\n输入顺序：\n问：这天至少花多少钱。\n根据 题目标签 观察与思考 以及了的假算 还有尝试建模 我们发现这题 显然 竟然可以使用网络 瘤 流做。\n#### 部分符号等表达：\n弧的表达：表示一条以为起点，为终点，容量为，单位流量花费为的一条有向弧\n，极大值\n：超级源点\n：超级汇点\n网络流常用建模技巧之拆点\n拆点，顾名思义，将题目中原本给定的一个点拆成两个或更多个。一般使用这种技巧的题目所使用的点都会对经过它的流进行操作。\n以本题为例，我们以一天作为一个点，但是我们发现我们无法区分干净的餐巾或者脏了的餐巾。因为网络流在计算的时候只会流一种液体。\n我们发现一个及其优良的性质，那就是将每一天拆成早上和晚上之后，晚上接收到的一定是脏了的餐巾，而早上接收的的餐巾一定是干净的。\n所以我们尝试把每一天拆成早上和晚上。第天的早上的点的编号是，晚上的点的编号是\n先考虑搁置的脏餐巾。我们显然可以把它从一天晚上移动到第二天晚上，所以对于，我们建立有向弧表示这些餐巾搁置一晚。\n然后考虑一下洗餐巾，这里只讨论快洗，因为慢洗同理。我们可以在第天晚上花费把一块餐巾送去快洗，然后在第天早上把他拿回来用。所以我们可以建立有向弧。\n考虑买，我们直接把到每一天早上之间建立有向弧，表示购买餐巾。\n我们发现方案满足当且仅当对于每一个，第天的早上都有至少块餐巾。将每一天早上向；连一条有向弧表示获取到的餐巾拿去用。\n那么我们每天晚上获得到的脏餐巾从哪里来？从早上直接连边？这不行，因为这样的话你早上不仅要把餐巾流向晚上，你还要流向。观察一下，我们发现因为每天都能够买，所以不会存在不合法的情况，所以每一天晚上获得的脏餐巾数量是固定的，那么我们直接从连过取去有向弧表示晚上获取了餐巾即可。\n这样的话，我们就已经建好一个合法的模型了。\n因为最大流我们确定一定是了，所以我们只需要在最大流条件下的最小费用就够了。\n直接费用流跑就行，网络流一般不卡也很难卡，所以他诈尸了。\n顺便讲一下费用流，他的本质就是以边费用为边权跑最短路，每次记录一个点最短路的前驱，然后从汇点向回追溯。\n\n因为一些离谱的原因，我去写了，题面是一样的，但是数据范围比较。。。。离谱，可以认为是上面那个的加强版。\n最终我靠着一些奇奇怪怪的小优化水了过去。\n这道题中的范围是，上面那题只有。\n直接套用上面那题的代码改一下输入和数组大小之后你就可以获得分的好成绩。现在来解决一下时间的问题。\n因为上面是单路增广，一次只能找到一条增广路，效率十分的低下。\n略加思考，我们发现这种单路增广的费用流和很像。\n那么我们是否可以使用的思想去优化多路增广？\n这是可以的。\n在中，我们记录了一个点能够延伸出去的点，并在的时候有方向的去找路，那么在多路增广费用流中我们可以通过最短路的更新来确定方向。\n形式化的说，记是到的最短路，如果对于一条有向弧，如果，那么我们认为点的最短路是从点延伸来的。\n这样我们的更新就有了方向。\n这样的话我们就能拿到分了。\n剩下的话还需要继续优化。\n相信各位都知道当前弧优化吧？\n（会的这段自动跳过）当前弧优化是指，如果说我们在之前经通过这条弧尝试增广了。那么在第二次及以后到达这个点的时候就不用再去遍历这条弧了。因为上一次我们已经“榨干”他的剩余价值了（大雾\n加上当前弧优化之后我们就能拿到分了。\n剩下的分如何获得？\n我们发现再对费用流算法优化已经比较困难了，所以我们尝试优化那部分。\n这里介绍两种优化：和优化。\n原先的算法中，我们每次更新一个点的最短路的时候都会把它插入到队列的尾部。\n但是插入到尾部不一定比插入到头部更优。\n我们知道，一般来说，最短路更小的点更容易更新其他点。\n优化就是将原先的队列更换成双端队列。在插入的时候与队首作比较，如果比队首要小，那么就插入到队首，否则插入到队尾。\n而优化就是记录一下当前队列中最短路的平均值， 每次取出一个点之后，如果发现这个店的最短路大于这个平均值就是扔到队尾换下一个去松弛。\n两个是可以同时使用的。\n当然，就算有了这两个优化，该被卡还是会被卡，而且一般来说这两个优化其实并不是特别大。\n不过对这道题已经足够了，加上优化之后就可以通过了。虽然最后一个点还是在掉的边缘徘徊\n","slug":"p1251&p4480_sol","date":"2021-12-31T06:12:49.000Z","categories_index":"题解","tags_index":"网络流","author_index":"Mr_Stranger_CW"},{"id":"a2e4333d19df6c81f99b80d42fb4ce9b","title":"CF691E Xor-sequences","content":"很好的一道矩阵加速题。\n题目大意:给定集合，一长为的数组中满足：\n$\n\n$\n求方案数。\n这题还是花了点时间的。众所周知不会给部分分数据范围，但是翻译者比较良心，顺带给了个对于的数据（咱也不知道是不是真的）。这个数据给了我们提示——可以先想小范围然后优化。\n考虑到每个元素的选取条件只与他相邻的有关，所以考虑一下\n我们设表示数组长度，第个元素是的时候的方案数。\n因为只有相邻的会限制条件，我们考虑用后面的限制前面的。\n对于一个数字放在这个位置上合法当且仅当\n所以我们有递推式。\n边界就是当时，\n最后的答案自然就是\n这个方法的复杂度是（枚举位置+枚举元素+计算）\n到这里我们可以开始优化了。\n各位看官有没有发现什么？\n我们的式子长这样\n。\n在每一次过程中，对于相同的，不论的取值，能够转移到上的是不变的。\n这个时候我们就可以考虑一下矩阵加速了。\n我们知道我们的矩阵应该满足：\n\n结合递推式，我们发现\\(C_{i,j}\\in{ \\ {0,1\\} }\\)\n结合矩阵乘法的方法我们有\n于是我们发现\n于是我们就可以愉快的求出转移矩阵啦。\n直接矩阵快速幂加速即可。\n捎带代码一份：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ninlind re(int &amp;x) {\n    x=0;\n    bool f=0;\n    int w=getchar();\n    while(w&lt;'0'||w&gt;'9'){if(w=='-')f = 1;w=getchar();}\n    while(w&lt;='9'&amp;&amp;w&gt;='0')x=(x&lt;&lt;3)+(x&lt;&lt;1)+w-'0',w=getchar();\n    if(f)x=-x;\n}\n\ninlint poc(int x){\n    int res=0;\n    while(x)res+=x&amp;1,x&gt;&gt;=1;\n    return res;\n}\nconst int M=1e9+7;\nint a[110];\nint ok[110][110];\nstruct mat{\n    int n,m;\n    int t[110][110];\n    mat operator *(const mat x){\n        mat c;\n        c.n=n;\n        c.m=x.m;\n        mem0(c.t);\n        if(m!=x.n) return c;\n        for(int i=1;i&lt;=n;i++)\n            for(int j=1;j&lt;=x.m;j++)\n                for(int k=1;k&lt;=m;k++)\n                    c.t[i][j]=(c.t[i][j]+t[i][k]*x.t[k][j]%M)%M;\n        return c;\n    }\n    mat unit(){\n        mat c;\n        c.n=n;\n        c.m=n;\n        mem0(c.t);\n        for(int i=1;i&lt;=n;i++)c.t[i][i]=1;\n        return c;\n    }\n};\nmat m_qp(mat a,int x){\n    mat ans=a.unit();\n    while(x){\n        if(x&amp;1)ans=ans*a;\n        a=a*a;\n        x&gt;&gt;=1;\n    }\n    return ans;\n}\nint n,k;\nsigned main(){\n    re(n);\n    re(k);\n    mat y;\n    y.n=y.m=n;\n    mem0(y.t);\n    mat o;\n    o.n=1;\n    o.m=n;\n    mem0(o.t);\n    for(int i=1;i&lt;=n;i++)re(a[i]);\n    for(int i=1;i&lt;=n;i++)\n        for(int j=1;j&lt;=n;j++)\n            if(poc(a[i]^a[j])%3==0)y.t[i][j]=1;\n\n    for(int i=1;i&lt;=n;i++)o.t[1][i]=1;\n    mat op=m_qp(y,k-1);\n    o=o*op;\n\n    int ans=0;\n    for(int i=1;i&lt;=n;i++)ans+=o.t[1][i],ans%=M;\n    cout&lt;&lt;ans;\n    return 0;\n}\n","slug":"cf691e","date":"2021-12-23T13:57:52.000Z","categories_index":"题解","tags_index":"主席树,LCA","author_index":"Mr_Stranger_CW"},{"id":"ffc0bfbaca0f679af652f6f962fbe80b","title":"CF577B Modulo Sum","content":"题意：给定和一个长度为$ n 的数列。求是否能够通过选择该序列的某一个自己，以令该子集的元素和可以被m$整除。\n看到这个选取子集，当时想到了三种做法。\n一：大力搜索\n二：状态压缩\n三：可行性背包\n稍微带点脑子思考一下，前两种。。。。。再见。直接开始考虑可行性背包的做法。\n设表示前个元素中能否有选取方法使得他们对取模得到。\n易得递推式：。\n最后的答案自然就是就是。\n这个时候看一下数据范围，，内存的话滚动优化，时间。。。啊。。。。。真不戳啊看起来会炸。\n这个时候考虑优化，但是背包的复杂度放在那里，优化也不是很好写，能优化的话早就有人干了。\n这个时候考虑换条路，既然没办法优化核心代码的复杂度，那么我们就想办法压缩数据范围。\n观察一下，如果我们按照区间选取元素的话，一段连续的区间的元素和正是两个前缀和相减的结果。\n我们令\n根据 小学数学中的 抽屉原理， 我们知道如果要有的话， 一共会有个前缀和，这个前缀和中一定会有两个同余。这个时候一定有合法的方案满足题目条件。\n然后来看的情况，观察数据范围，此时，直接背包有手就行。\nP.S. 遇到一些离谱的数据的时候如果没有办法优化核心可以选择用一些 离谱 的方法去压缩数据，例：抽屉原理，容斥，打表找规律。真·从源头上解决问题\n其实还有一道类似的，。\n题面大意是给定五维空间里的个点，判断那些点不存在另外两个点使得是锐角。\n这题实际上就是的暴力，不过的范围还是很难受的，这个时候抽屉原理可得当的时候，至少一个象限会出现个点，以此压缩范围。\n","slug":"cf577b","date":"2021-12-20T11:17:02.000Z","categories_index":"题解","tags_index":"DP,数学","author_index":"Mr_Stranger_CW"},{"id":"1e0119e498bc7b0061fdcbba2c4edc86","title":"蒟蒻的进阶数论","content":"$\n","slug":"number_theory_advanced","date":"2021-12-16T13:56:08.000Z","categories_index":"学习笔记","tags_index":"数学","author_index":"Mr_Stranger_CW"},{"id":"cd86f5c4c043b099375892929ad2a490","title":"CF484D Kindergarten","content":"题意：给定一个数列，你可以把将数组分为任意个块。对于一个划分方案，他的分数是每个块中最大值与最小值的差的和。求最大分数。\n这个题看起来好像和数论有关系，但是实际上和数论没啥关系。\n我们首先将整个数列的变化趋势画成草图\n大概就是这个样子。 \n这个时候，我们的问题就转变成了在这个图像上找几条分界线，使得每一块内最高点和最低点的差的和最大。\n首先我们知道，一个区间的的分数最小值就是。（这显然）\n我们先来随便划分一下。\n 现在我们先只关注红线之内的区间。设他的最低点位于，最高点位于，这个区间所贡献的分数就是\n在这个红线之内，存在了一个下凹点。\n此时我们将这个下凹点作为分界线再次分段，有两种可能：\n\n原先的最高点和最低点在一起。\n这样我们就得到了两个区间，一个区间是原先的最大值所在的那一部分，它所能贡献的分数就是，而另一个区间能贡献的分数我们设为\n重新划分后，划分后的原先区间现在能够贡献的分数是，因为，所以我们有不等式\n\n原先的最高点和最低点不在一起。\n我们得到两个区间，第一个区间里有我们的最高点，此时我们把下凹点分配到最高点区间，设下凹点坐标为。\n而在最低点区间中，现有的最高点坐标为，因为我们知道下凹点的两侧点一定比下凹点高或相等，所以有\n那么这个时候的区间贡献即为\n因为，我们设，其中\n带入式子得到\n因为，所以\n所以对于每一个区间，只要里面有下凹点，把下凹点作为新的分界线去划分一定更优。\n同理可证以上凸点划分也更优。\n我们发现我们每次都是在上凸点或者下凹点周围划分，于是我们发现我们划出来的一定都是单调区间。\n所以我们只需要保证所有的块单调即可。至于点掉的区间内是否需要再分，我们来思考一下。\n首先，对于区间内一点，我们把他分开的话，如果分裂后一区间可取这点，则另一区间不可。\n由于单调，如果我们将这个点分到高点一侧，我们会发现，另一区间的最高点一定不高于我们的分裂点，因为我们现在考虑的是单调区间。所以答案一定不会更优。\n至于下凹点和上凸点本身要划分到那个哪个区间，直接判断大小即可。\n我们使用来实现。\n设表示前个数字的最高划分分数。\n记是的最后一个下凹/上凸点，得到方程\n\n判断下凹/上凸就判断一下两边是不是大于/小于自己即可。\n附AC代码： //#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;math.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;istream&gt;\n#include &lt;string&gt;\n#include &lt;queue&gt;\n#include &lt;deque&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;string.h&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#define inlind inline void\n#define inlinl inline bool\n#define inlint inline int\n#define inlinc inline char\n#define inlins inline string\n#define mem0(a) memset(a,0,sizeof(a))\n#define memf(a) memset(a,0x3f,sizeof(a))\nusing namespace std;\nlong long  n,a[1000300];\nlong long dp[1000300];\nint last=1;\ninlind check(int x){\n    if((a[x]&gt;=a[x-1]&amp;&amp;a[x]&gt;=a[x+1])||(a[x]&lt;=a[x-1]&amp;&amp;a[x]&lt;=a[x+1])) last=x;\n}\nsigned main(){\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];\n    for(int i=2;i&lt;=n;i++){\n        dp[i]=max(dp[last]+abs(a[last+1]-a[i]),dp[last-1]+abs(a[last]-a[i]));\n        check(i);\n    }\n    cout&lt;&lt;dp[n];\n    return 0;\n}\n\n","slug":"cf484d","date":"2021-12-13T04:05:44.000Z","categories_index":"题解","tags_index":"贪心,DP","author_index":"Mr_Stranger_CW"},{"id":"8d70ee8794d49044ce20f692acc9dc7a","title":"蒟蒻浅谈扩展卢卡斯","content":"扩展卢卡斯\n一个除了名字以外和卢卡斯定理没有任何关系的东西。\n对比一下和:\n\n适用于组合数取模 废话\n要求模数是质数\n时间复杂度\n\n适用于组合数取模 又是废话\n对模数没有要求\n时间复杂度：\n设模数有个质因子，质因子的次数为。\n总复杂度大约是\n因为往往很大，不好预处理逆元。\n前置知识\n中国剩余定理\n乘法逆元\n扩展欧几里得定理\n以上不会戳这里\n直接讲：\n解决的问题：给定，求\n首先，因为模数非质数的限制 以及先人的智慧 我们可以很快的想到使用分解原模数，变成质数的次幂形式进行求解。\n我们设为答案,即。\n现在我们得到了一个同余方程组\n$\n\n$\n其中 。\n现在问题转变为如何求出，即\n先把式子写出来\n要求 :\n\n\n我们发现原来用逆元去求取答案的方式不能实现，因为可能有的倍数使得不存在逆元\n于是我们考虑提出这里面所有的的倍数，使得逆元可做。\n得到：\n\n现在同余式右边的分数部分就可以使用逆元求解了。\n现在问题转变为：如何求？\n现在我们举一个例子 别问为啥，你行你给我整个公式出来\n当时\n\n提出其中的倍数，\n不难想到 小学数学 共有个是的倍数。\n得到\n\n发现对于被提出的倍数的那一部分提完之后就可以作为一个单独的阶乘，我们可以递归求取。不难发现，这个阶乘也是。\n我们再次观察剩下的那一堆与互质的乘积。\n\n我们发现 实际上是先人的智慧 :\n\n于是得到剩下的数字是有循环节的。以为一节。我们先暴力扫出来一节，然后可以直接使用快速幂。剩下的余节暴力扫。\n现在，我们称将分解之后：\n前面为，\n中间为\n最后循环节和余节的部分为\n我们先前已经去掉了所有的倍数，所以直接扔。\n于是答案就是。\n我们将其写成递归函数的形式\n对于求取\n$ f_{p_i^{k_i}}(x)=\n\n$\n现在我们算出了，由于我们已经去除过因子，所以最终模数与互质，扩欧求逆元即可。\n于是我们算出了每一个！\n现在我们就直接上或者求解就行\n请配合代码食用！！！！\n#include &lt;bits/stdc++.h//#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;math.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;istream&gt;\n#include &lt;string&gt;\n#include &lt;queue&gt;\n#include &lt;deque&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;string.h&gt;\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#define int long long\n#define inlind inline void\n#define inlinl inline bool\n#define inlint inline int\n#define inlinc inline char\n#define inlins inline string\n#define mem0(a) memset(a,0,sizeof(a))\n#define memf(a) memset(a,0x3f,sizeof(a))\n#define mem_f(a) memset(a,0x80,sizeof(a))\n#define mem_1(a) memset(a,-1,sizeof(a))\n#define pb(a,b) a.push_back(b)\n#define mp(a,b) make_pair(a,b)\n#define p1(x) x.first\n#define p2(x) x.second\nusing namespace std;\nint n,m,p;\nbool pr[1000300];\nint prs[100030];\nint total;\nstruct node {int p,pk,m;}a[100030];\nint M[100030];\nint sum;\ninlind opr(){//质数筛预处理，一会要分解质因数\n    int n=1e6;\n    memset(pr,1,sizeof(pr));\n    pr[1]=0;\n    for(int i=2;i&lt;=n;i++){\n        if(pr[i]){prs[++total]=i;}\n               for(int j=1;j&lt;=total;j++){\n                   if(i*prs[j]&gt;n) break;\n                   pr[i*prs[j]]=0;\n                   if(i% prs[j]==0){\n                       break;\n                   }\n\n           }\n       }\n}\ninlint qp(int a,int x,int p){//快速幂\n    int ans=1,res=a;\n    while(x){\n        if(x&amp;1){\n            ans*=res;\n            ans%=p;\n        }\n        res*=res;\n        x&gt;&gt;=1;\n        res%=p;\n    }\n    return ans;\n}\ninlind exgcd(int a,int b,int &amp;x,int &amp;y){//扩展欧几里得\n    if (!b) {\n        x=1;\n        y=0;\n        return ;\n\n    }\n    exgcd(b,a%b,x,y);\n    int t=x;\n    x=y;\n    y=t-a/b*y;\n}\ninlint inv(int a,int p){//求逆元\n    int x,y;\n    exgcd(a,p,x,y);\n    return (x%p+p)%p;\n}\ninlint fr(int n,int p,int pk){//计算阶乘取模\n    if(n==0) return 1;\n    int ans=1;\n    for(int i=1;i&lt;pk;i++)if(i%p)ans*=i,ans%=pk;//暴力计算循环节\n    ans=qp(ans,n/pk,pk);\n    for(int i=1;i&lt;=n%pk;i++)if(i%p)ans*=i,ans%=pk;//暴力计算余节\n    return ans*fr(n/p,p,pk)%pk;//递归求解小阶乘\n}\ninlint calc(int n,int m,int p,int pk){//计算ai\n    if(n&lt;m) return 0;\n    int cnt=0;\n    int op=p;\n    for(int i=1;op&lt;=n;i++)cnt+=n/op,op*=p;//提取pi因子\n    op=p;\n    for(int i=1;op&lt;=m;i++)cnt-=m/op,op*=p;\n    op=p;\n    for(int i=1;op&lt;=n-m;i++)cnt-=(n-m)/op,op*=p;\n    return qp(p,cnt,pk) *  fr(n,p,pk)  % pk * inv( fr(m,p,pk) ,pk) % pk * inv( fr(n-m,p,pk) ,pk) % pk;//乘上阶乘取模和逆元以及因子个数即为答案\n\n}\n\nsigned main(){\n    opr();\n\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;\n    int w=p;\n    for(int i=1;i&lt;=total&amp;&amp;prs[i]&lt;=p;i++){\n        int cntt=1;\n        while(p%prs[i]==0){\n            p/=prs[i];\n            cntt*=prs[i];\n        }\n        if(cntt!=1)\n            a[++sum]={prs[i],cntt,calc(n,m,prs[i],cntt)};\n    }\n\n    //CRT\n\n    for(int i=1;i&lt;=sum;i++)M[i]=w/a[i].pk;\n    int ans=0;\n    for(int i=1;i&lt;=sum;i++){\n        ans+=inv(M[i],a[i].pk)*M[i]%w*a[i].m%w;\n        ans%=w;\n    }\n    //输出答案，结束\n    cout&lt;&lt;ans%w;;\n    return 0;//代码再见\n}\n\n","slug":"exlucas","date":"2021-12-04T12:51:36.000Z","categories_index":"学习笔记","tags_index":"数学","author_index":"Mr_Stranger_CW"},{"id":"973149a040ff801e3dde0212f12e6f76","title":"CF1607D Blue-Red Permutation","content":"CF1607D\n题意简述：给定个数字，每个数字有一个颜色，若为红色则该数字可以进行的操作，若为蓝色可以进行的操作。问是否存在一种操作的序列，使得最后的个数互不相同且均小于等于\n我们先转换一下题意：红色的数字表示这一位可以取到所有大于等于他的数字，蓝色的则可以取到所有大于等于它的数字。\n首先，我们对他排个序，然后贪心的去取。\n贪心策略：将颜色作为第一关键字排序，该数数值作为第二关键字排序。\n取的时候：对于一个数字，他若是蓝色的，则找到最小的一个可被取到且未被其他数字取到的数值。不存在就不取。红色的话就找最小的大于等于它的未被取的数值。不存在就不取。\n正确性的话，前面好多位大佬说的还是挺清楚的，只不过他们是枚举然后去找，其实和我这个是差不多的。（主要还是因为本人语文太差，讲不清楚。）\n然后来看一下怎么实现。\n我们首先将扔到一个集合中，蓝色就取毕竟直接排序不用白不用，要是的值大于就不取。红色就二分查找。要是找不到就不取。取走的直接掉。\n最后判一下是否为空即可，为空就意味着都被取走了。反之则没有。\n但是！！！\n这么干我T飞了啊。。。。。。。。。。。。。理论上来说增删改查不是嘛。。。。。这样算下来应该是的\n也可能是我人菜自带大常数吧\n于是我选择了另一种方法，理论上来说复杂度是没有很优的，整体多套了一个上去。。。\n不过他过了(doge\n他就是二分前缀和加树状数组优化！！！\n数组上一开始给这个数每个数赋为，然后搞成树状数组。\n查找在未取集合之中大于等于的最小值的时候。\n我们就二分前缀和，边界设为，每次调取到的区间和，若是非零则代表这其中有数字还没有被取走，。反之没有，。\n然后要是想要取最小的未被取走的值，相当于查找最小的大于等于的数字，直接套就行了。\n详情请食用代码注释！\n//#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;math.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;istream&gt;\n#include &lt;string&gt;\n#include &lt;queue&gt;\n#include &lt;deque&gt;\n#include &lt;stack&gt;\n#include &lt;set&gt;\n#include &lt;string.h&gt;\n#include &lt;map&gt;\nusing namespace std;\n#define int long long\nint t;\nint n;\n \nint tr[200030];//树状数组\ninline int lb(int x){\n    return x&amp;-x;\n}\ninline void up(int x,int k){//树状数组更新\n    while(x&lt;=n){\n        tr[x]+=k;\n        x+=lb(x);\n    }\n}\ninline int g(int x){//树状数组求前缀和\n    int res=0;\n    while(x&gt;0){\n        res+=tr[x];\n        x-=lb(x);\n    }\n    return res;\n}\nstruct node {int val,col;}a[200300];\ninline bool cmp(node x,node y){\n    return x.col!=y.col?x.col&gt;y.col:x.val&lt;y.val;//蓝色在前，然后数值排序\n}\ninline int trbin_b(int x){\n    int l=x,r=n+1;\n    while(l&lt;r){\n        int mid=(l+r)&gt;&gt;1;\n        if((g(mid)-g(l-1))&gt;0)r=mid;//二分前缀和\n        else l=mid+1;\n    }\n    return r;\n}\n \nint cnt;\nsigned main(){\n    cin&gt;&gt;t;\n    while(t--){\n        cin&gt;&gt;n;\n        for(int i=1;i&lt;=n;i++)scanf(\"%lld\",&amp;a[i].val);\n        for(int i=1;i&lt;=n;i++){\n            char p;\n            cin&gt;&gt;p;\n            if(p=='B')\n                a[i].col=1;\n            else a[i].col=0;\n            up(i,1);//先给每个值的当成没有被取走\n        }\n        cnt=0;//记录取走了几个，每次记得更新\n        sort(a+1,a+n+1,cmp);//排序\n        \n        for(int i=1;i&lt;=n;i++){\n            if(a[i].col==1){\n                int it=trbin_b(1);\n                if(a[i].val&gt;=it&amp;&amp;it&lt;n+1){//判断是否越界，要是n-1的话说明不存在\n                    cnt++;//记录个数\n                    up(it,-1);//把它取走\n                }\n            }\n            \n            else{\n                int it=trbin_b(a[i].val);\n                if(it&lt;n+1){//判断是否越界\n                    cnt++;\n                    up(it,-1);\n                }\n            }\n        }\n        for(int i=1;i&lt;=n;i++){\n            tr[i]=0;//盘回来\n        }\n        if(cnt!=n)printf(\"NO\\n\");//cnt判断，等于n就是取完了，反之则失败\n        else printf(\"YES\\n\");\n        \n        \n    }\n   \nreturn 0;}\n","slug":"cf1607d_sol","date":"2021-11-10T05:19:08.000Z","categories_index":"题解","tags_index":"贪心","author_index":"Mr_Stranger_CW"},{"id":"d6677ef83cf516f9da01e2e0359e5740","title":"基础动态规划优化","content":"$\n","slug":"knapsack","date":"2021-08-27T07:02:18.000Z","categories_index":"学习笔记","tags_index":"DP","author_index":"Mr_Stranger_CW"},{"id":"a9b4a28baabd86507f60c4a1ea9c757b","title":"蒟蒻的基础数论","content":"令人裂开的$\n","slug":"number_theory_basic","date":"2021-07-22T05:48:46.000Z","categories_index":"学习笔记","tags_index":"数学","author_index":"Mr_Stranger_CW"}]